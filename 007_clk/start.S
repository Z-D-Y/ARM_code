
.text
.global _start
 
 _start:

/*************************************************************************/
	/* 关闭看门狗 */
	ldr r0, =0x53000000
	ldr r1, =0
	str r1, [r0]

/*************************************************************************/
	/* 设置MPLL, FCLK : HCLK : PCLK = 400MHz : 100MHz : 50MHz */
	/* 1 设置LOCKTIME(0x4C000000) = 0xFFFFFFFF 
	 * 即设置锁定时间，在其期间内CPU停止工作
	 */
	 ldr r0, =0x4C000000
	 ldr r1, =0xFFFFFFFF
	 str r1, [r0]

	/* 2 CLKDIVN(0x4C000014) = 0x5, FCLK : HCLK : PCLK =8:4:1
	 * HDIVN = CLKDIVN[2:1] = 10; 即HCLK = FCLK/4;
	 * PDIVN = CLKDIVN[0] = 1; 即PCLK = FCLK/8;
	 */
	 ldr r0, =0x4C000014
	 ldr r1, =0x5
	 str r1, [r0]

	/* 3 设置CPU工作在异步模式(因为上一步骤改变了HDIVN的值为 1 ) */
	mrc p15,0,r0,c1,c0,0
	orr r0,r0,#0xC0000000   //R1_nF:OR:R1_iA
	mcr p15,0,r0,c1,c0,0

	/* 4 设置MPLLCON(0x4C000004) = (92<12)|(1<4)|(1<0)
	 * m = MDIV +8 =92+8 = 100
	 * p = PDIV +2 =1+2 = 3
	 * s = SDIV = 1
	 * FCLK = MPLL = (2*m*Fin)/(p*2^s) = (2*100*12)/(3*2^1) = 400MHz
	 */
	 ldr r0, =0x4C000004
	 ldr r1, =(92<<12)|(1<<4)|(1<<0)
	 str r1, [r0]

	/* 一旦设置PLL，就会锁定LOCK TIME直到PLL输出稳定
	 * 然后CPU工作在新的频率FCLK下
	 */

/*************************************************************************/
	/* 设置内存: sp 栈
	 * 分辨nor/nand启动 
	 * 写0到0地址，在读出来
	 * 如果得到零，表示0地址上的内容被修改了，它对应RAM,这就是nand启动
	 * 否则就是nor启动
	 */
	mov r1, #0
	ldr r0, [r1]	/*读出原来的值备份*/
	str r1, [r1]	/*0->[0]*/
	ldr r2, [r1]	/*r2=[0]*/
	cmp r1,r2		/*r1==r2? 如果相等表示nand启动*/
	ldr sp, =0x40000000+4096	/*先假设是nor启动*/
	moveq sp, #4096	/*设置nand启动*/
	streq r0, [r1]	/*恢复原来的值*/

/*************************************************************************/

	bl main	
	
/*************************************************************************/

halt:
	b halt



	
